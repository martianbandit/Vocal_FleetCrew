// PWA utilities for installation prompts and lifecycle management\nclass PWAManager {\n  constructor() {\n    this.deferredPrompt = null;\n    this.isInstalled = false;\n    this.isStandalone = false;\n    this.callbacks = {\n      beforeInstallPrompt: [],\n      appInstalled: [],\n      onlineStatus: []\n    };\n    \n    this.init();\n  }\n\n  init() {\n    // Check if app is running in standalone mode\n    this.isStandalone = window.matchMedia('(display-mode: standalone)').matches ||\n                        window.navigator.standalone ||\n                        document.referrer.includes('android-app://');\n\n    // Listen for beforeinstallprompt event\n    window.addEventListener('beforeinstallprompt', (e) => {\n      console.log('PWA: Install prompt available');\n      e.preventDefault();\n      this.deferredPrompt = e;\n      this.trigger('beforeInstallPrompt', e);\n    });\n\n    // Listen for app installed event\n    window.addEventListener('appinstalled', (e) => {\n      console.log('PWA: App was installed');\n      this.isInstalled = true;\n      this.deferredPrompt = null;\n      this.trigger('appInstalled', e);\n    });\n\n    // Listen for online/offline events\n    window.addEventListener('online', () => {\n      console.log('PWA: Back online');\n      this.trigger('onlineStatus', { online: true });\n    });\n\n    window.addEventListener('offline', () => {\n      console.log('PWA: Gone offline');\n      this.trigger('onlineStatus', { online: false });\n    });\n\n    // Listen for service worker messages\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.addEventListener('message', (event) => {\n        console.log('PWA: Service Worker message:', event.data);\n        \n        if (event.data.type === 'SYNC_COMPLETE') {\n          this.trigger('syncComplete', event.data.data);\n        }\n      });\n    }\n  }\n\n  // Show install prompt\n  async showInstallPrompt() {\n    if (!this.deferredPrompt) {\n      console.log('PWA: No install prompt available');\n      return false;\n    }\n\n    // Show the install prompt\n    this.deferredPrompt.prompt();\n\n    // Wait for the user to respond to the prompt\n    const { outcome } = await this.deferredPrompt.userChoice;\n    console.log(`PWA: User response to install prompt: ${outcome}`);\n    \n    // Clear the deferredPrompt\n    this.deferredPrompt = null;\n    \n    return outcome === 'accepted';\n  }\n\n  // Check if installation is available\n  canInstall() {\n    return this.deferredPrompt !== null && !this.isInstalled && !this.isStandalone;\n  }\n\n  // Check if app is installed/standalone\n  isAppInstalled() {\n    return this.isStandalone;\n  }\n\n  // Register for background sync\n  async registerBackgroundSync(tag = 'sync-inspection-data') {\n    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {\n      try {\n        const registration = await navigator.serviceWorker.ready;\n        await registration.sync.register(tag);\n        console.log('PWA: Background sync registered:', tag);\n        return true;\n      } catch (error) {\n        console.error('PWA: Background sync registration failed:', error);\n        return false;\n      }\n    }\n    return false;\n  }\n\n  // Request notification permission\n  async requestNotificationPermission() {\n    if ('Notification' in window) {\n      const permission = await Notification.requestPermission();\n      console.log('PWA: Notification permission:', permission);\n      return permission === 'granted';\n    }\n    return false;\n  }\n\n  // Show local notification\n  showNotification(title, options = {}) {\n    if ('Notification' in window && Notification.permission === 'granted') {\n      const notification = new Notification(title, {\n        icon: '/icon-192.png',\n        badge: '/icon-192.png',\n        ...options\n      });\n      \n      // Auto-close after 5 seconds\n      setTimeout(() => notification.close(), 5000);\n      \n      return notification;\n    }\n    return null;\n  }\n\n  // Event system\n  on(event, callback) {\n    if (this.callbacks[event]) {\n      this.callbacks[event].push(callback);\n    }\n  }\n\n  off(event, callback) {\n    if (this.callbacks[event]) {\n      this.callbacks[event] = this.callbacks[event].filter(cb => cb !== callback);\n    }\n  }\n\n  trigger(event, data) {\n    if (this.callbacks[event]) {\n      this.callbacks[event].forEach(callback => callback(data));\n    }\n  }\n\n  // Get network status\n  isOnline() {\n    return navigator.onLine;\n  }\n\n  // Get device info\n  getDeviceInfo() {\n    return {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      online: navigator.onLine,\n      cookieEnabled: navigator.cookieEnabled,\n      touchSupport: 'ontouchstart' in window || navigator.maxTouchPoints > 0,\n      standalone: this.isStandalone,\n      orientation: screen.orientation ? screen.orientation.type : 'unknown'\n    };\n  }\n\n  // Share API integration\n  async share(data) {\n    if (navigator.share) {\n      try {\n        await navigator.share(data);\n        return true;\n      } catch (error) {\n        console.log('PWA: Share cancelled or failed:', error);\n        return false;\n      }\n    }\n    \n    // Fallback: copy to clipboard\n    if (navigator.clipboard && data.text) {\n      try {\n        await navigator.clipboard.writeText(data.text);\n        return true;\n      } catch (error) {\n        console.error('PWA: Clipboard write failed:', error);\n      }\n    }\n    \n    return false;\n  }\n}\n\n// Mobile-specific utilities\nclass MobileUtils {\n  // Vibrate device\n  static vibrate(pattern = [100]) {\n    if ('vibrate' in navigator) {\n      navigator.vibrate(pattern);\n      return true;\n    }\n    return false;\n  }\n\n  // Get battery info\n  static async getBatteryInfo() {\n    if ('getBattery' in navigator) {\n      try {\n        const battery = await navigator.getBattery();\n        return {\n          level: Math.round(battery.level * 100),\n          charging: battery.charging,\n          chargingTime: battery.chargingTime,\n          dischargingTime: battery.dischargingTime\n        };\n      } catch (error) {\n        console.warn('Battery API not available:', error);\n      }\n    }\n    return null;\n  }\n\n  // Lock screen orientation\n  static async lockOrientation(orientation = 'portrait-primary') {\n    if (screen.orientation && screen.orientation.lock) {\n      try {\n        await screen.orientation.lock(orientation);\n        return true;\n      } catch (error) {\n        console.warn('Orientation lock failed:', error);\n      }\n    }\n    return false;\n  }\n\n  // Unlock screen orientation\n  static unlockOrientation() {\n    if (screen.orientation && screen.orientation.unlock) {\n      screen.orientation.unlock();\n      return true;\n    }\n    return false;\n  }\n\n  // Wake lock (keep screen on)\n  static async requestWakeLock() {\n    if ('wakeLock' in navigator) {\n      try {\n        const wakeLock = await navigator.wakeLock.request('screen');\n        console.log('Wake lock acquired');\n        return wakeLock;\n      } catch (error) {\n        console.warn('Wake lock failed:', error);\n      }\n    }\n    return null;\n  }\n\n  // Check if device has camera\n  static async hasCameraAccess() {\n    if ('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices) {\n      try {\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        return devices.some(device => device.kind === 'videoinput');\n      } catch (error) {\n        console.warn('Camera access check failed:', error);\n      }\n    }\n    return false;\n  }\n\n  // Get device motion permission (iOS 13+)\n  static async requestMotionPermission() {\n    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {\n      try {\n        const permission = await DeviceMotionEvent.requestPermission();\n        return permission === 'granted';\n      } catch (error) {\n        console.warn('Motion permission request failed:', error);\n      }\n    }\n    return true; // Assume granted on non-iOS devices\n  }\n}\n\n// Create singleton instances\nconst pwaManager = new PWAManager();\n\nexport { pwaManager, MobileUtils };
