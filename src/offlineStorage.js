// Offline storage utility using IndexedDB\nclass OfflineStorage {\n  constructor() {\n    this.dbName = 'VoiceInspectionDB';\n    this.version = 1;\n    this.db = null;\n  }\n\n  // Initialize IndexedDB\n  async init() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\n      request.onerror = () => {\n        console.error('Failed to open IndexedDB:', request.error);\n        reject(request.error);\n      };\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        console.log('IndexedDB initialized successfully');\n        resolve(this.db);\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        \n        // Create object store for inspections\n        if (!db.objectStoreNames.contains('inspections')) {\n          const inspectionStore = db.createObjectStore('inspections', {\n            keyPath: 'id',\n            autoIncrement: true\n          });\n          \n          // Create indexes\n          inspectionStore.createIndex('timestamp', 'timestamp', { unique: false });\n          inspectionStore.createIndex('status', 'status', { unique: false });\n          inspectionStore.createIndex('synced', 'synced', { unique: false });\n        }\n\n        // Create object store for app settings\n        if (!db.objectStoreNames.contains('settings')) {\n          db.createObjectStore('settings', { keyPath: 'key' });\n        }\n        \n        console.log('IndexedDB schema created/updated');\n      };\n    });\n  }\n\n  // Save inspection data offline\n  async saveInspection(inspectionData) {\n    if (!this.db) await this.init();\n    \n    const inspection = {\n      ...inspectionData,\n      timestamp: new Date().toISOString(),\n      synced: false,\n      offline: !navigator.onLine\n    };\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['inspections'], 'readwrite');\n      const store = transaction.objectStore('inspections');\n      const request = store.add(inspection);\n\n      request.onsuccess = () => {\n        console.log('Inspection saved offline with ID:', request.result);\n        resolve(request.result);\n      };\n\n      request.onerror = () => {\n        console.error('Failed to save inspection:', request.error);\n        reject(request.error);\n      };\n    });\n  }\n\n  // Get all inspections\n  async getAllInspections() {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['inspections'], 'readonly');\n      const store = transaction.objectStore('inspections');\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n\n      request.onerror = () => {\n        reject(request.error);\n      };\n    });\n  }\n\n  // Get unsynced inspections\n  async getUnsyncedInspections() {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['inspections'], 'readonly');\n      const store = transaction.objectStore('inspections');\n      const index = store.index('synced');\n      const request = index.getAll(false);\n\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n\n      request.onerror = () => {\n        reject(request.error);\n      };\n    });\n  }\n\n  // Mark inspection as synced\n  async markInspectionSynced(id) {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['inspections'], 'readwrite');\n      const store = transaction.objectStore('inspections');\n      const getRequest = store.get(id);\n\n      getRequest.onsuccess = () => {\n        const inspection = getRequest.result;\n        if (inspection) {\n          inspection.synced = true;\n          inspection.syncedAt = new Date().toISOString();\n          \n          const updateRequest = store.put(inspection);\n          updateRequest.onsuccess = () => resolve(inspection);\n          updateRequest.onerror = () => reject(updateRequest.error);\n        } else {\n          reject(new Error('Inspection not found'));\n        }\n      };\n\n      getRequest.onerror = () => {\n        reject(getRequest.error);\n      };\n    });\n  }\n\n  // Delete inspection\n  async deleteInspection(id) {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['inspections'], 'readwrite');\n      const store = transaction.objectStore('inspections');\n      const request = store.delete(id);\n\n      request.onsuccess = () => {\n        resolve(true);\n      };\n\n      request.onerror = () => {\n        reject(request.error);\n      };\n    });\n  }\n\n  // Save app settings\n  async saveSetting(key, value) {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['settings'], 'readwrite');\n      const store = transaction.objectStore('settings');\n      const request = store.put({ key, value, updatedAt: new Date().toISOString() });\n\n      request.onsuccess = () => {\n        resolve(value);\n      };\n\n      request.onerror = () => {\n        reject(request.error);\n      };\n    });\n  }\n\n  // Get app setting\n  async getSetting(key, defaultValue = null) {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['settings'], 'readonly');\n      const store = transaction.objectStore('settings');\n      const request = store.get(key);\n\n      request.onsuccess = () => {\n        const result = request.result;\n        resolve(result ? result.value : defaultValue);\n      };\n\n      request.onerror = () => {\n        reject(request.error);\n      };\n    });\n  }\n\n  // Clear all data\n  async clearAllData() {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['inspections', 'settings'], 'readwrite');\n      \n      const inspectionStore = transaction.objectStore('inspections');\n      const settingsStore = transaction.objectStore('settings');\n      \n      const clearInspections = inspectionStore.clear();\n      const clearSettings = settingsStore.clear();\n      \n      transaction.oncomplete = () => {\n        console.log('All offline data cleared');\n        resolve(true);\n      };\n      \n      transaction.onerror = () => {\n        reject(transaction.error);\n      };\n    });\n  }\n\n  // Get storage usage info\n  async getStorageInfo() {\n    try {\n      if ('storage' in navigator && 'estimate' in navigator.storage) {\n        const estimate = await navigator.storage.estimate();\n        return {\n          quota: estimate.quota,\n          usage: estimate.usage,\n          usagePercentage: Math.round((estimate.usage / estimate.quota) * 100)\n        };\n      }\n    } catch (error) {\n      console.warn('Storage API not available:', error);\n    }\n    return null;\n  }\n}\n\n// Create singleton instance\nconst offlineStorage = new OfflineStorage();\n\n// Initialize on first import\nofflineStorage.init().catch(console.error);\n\nexport default offlineStorage;
