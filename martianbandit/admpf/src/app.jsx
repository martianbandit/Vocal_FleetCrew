import React, { useState, useEffect, useCallback } from 'react';\nimport './app.css';\nimport offlineStorage from './offlineStorage';\nimport { pwaManager, MobileUtils } from './pwaUtils';\n\nconst VoiceInspectionAssistant = () => {\n  const [isListening, setIsListening] = useState(false);\n  const [transcription, setTranscription] = useState('');\n  const [currentQuestion, setCurrentQuestion] = useState(0);\n  const [responses, setResponses] = useState([]);\n  const [pendingResponse, setPendingResponse] = useState(null);\n  const [showConfirmation, setShowConfirmation] = useState(false);\n  const [validationMessage, setValidationMessage] = useState('');\n  \n  // PWA and offline states\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const [showInstallPrompt, setShowInstallPrompt] = useState(false);\n  const [offlineInspections, setOfflineInspections] = useState([]);\n  const [syncStatus, setSyncStatus] = useState('');\n  const [deviceCapabilities, setDeviceCapabilities] = useState({});\n  const [wakeLock, setWakeLock] = useState(null);\n\n  const questions = [\n    // Freinage\n    { key: 'brake_pads', type: 'numeric', question: "Quelle est l'√©paisseur des plaquettes de frein en millim√®tres ?", tolerance: '>= 3', unit: 'mm' },\n    { key: 'brake_fluid', type: 'boolean', question: 'Le niveau de liquide de frein est-il correct ? R√©pondez par oui ou non.' },\n    \n    // Pneumatiques\n    { key: 'tire_tread', type: 'numeric', question: 'Quelle est la profondeur de sculpture des pneus en millim√®tres ?', tolerance: '>= 1.6', unit: 'mm' },\n    { key: 'tire_pressure', type: 'numeric', question: 'Quelle est la pression des pneus en bars ?', tolerance: '2.0-2.5', unit: 'bar' },\n    \n    // √âclairage\n    { key: 'headlights', type: 'boolean', question: 'Les phares avant fonctionnent-ils correctement ? R√©pondez par oui ou non.' },\n    { key: 'taillights', type: 'boolean', question: 'Les feux arri√®re fonctionnent-ils correctement ? R√©pondez par oui ou non.' },\n    { key: 'indicators', type: 'boolean', question: 'Les clignotants fonctionnent-ils tous ? R√©pondez par oui ou non.' },\n    \n    // Fluides\n    { key: 'oil_level', type: 'boolean', question: "Le niveau d'huile moteur est-il correct ? R√©pondez par oui ou non." },\n    { key: 'coolant_level', type: 'boolean', question: 'Le niveau de liquide de refroidissement est-il correct ? R√©pondez par oui ou non.' },\n    \n    // M√©canique\n    { key: 'belt_condition', type: 'descriptive', question: "D√©crivez l'√©tat de la courroie. Est-elle en bon √©tat, us√©e, ou √† remplacer ?" },\n    { key: 'battery_voltage', type: 'numeric', question: 'Quelle est la tension de la batterie en volts ?', tolerance: '>= 12.4', unit: 'V' },\n    \n    // Carrosserie et s√©curit√©\n    { key: 'windshield', type: 'boolean', question: 'Le pare-brise est-il en bon √©tat sans fissures ? R√©pondez par oui ou non.' },\n    { key: 'horn', type: 'boolean', question: 'Le klaxon fonctionne-t-il ? R√©pondez par oui ou non.' },\n    { key: 'mirrors', type: 'boolean', question: 'Tous les r√©troviseurs sont-ils en bon √©tat ? R√©pondez par oui ou non.' },\n    \n    // Suspension et direction\n    { key: 'suspension', type: 'descriptive', question: "Comment d√©crivez-vous l'√©tat de la suspension ? Bonne, moyenne, ou mauvaise ?" },\n    { key: 'steering', type: 'boolean', question: 'La direction r√©pond-elle correctement sans jeu excessif ? R√©pondez par oui ou non.' }\n  ];\n\n  // Initialize PWA features\n  useEffect(() => {\n    const initializePWA = async () => {\n      // Check device capabilities\n      const capabilities = {\n        touchSupport: 'ontouchstart' in window || navigator.maxTouchPoints > 0,\n        vibrationSupport: 'vibrate' in navigator,\n        cameraAccess: await MobileUtils.hasCameraAccess(),\n        batteryInfo: await MobileUtils.getBatteryInfo(),\n        isStandalone: pwaManager.isAppInstalled()\n      };\n      setDeviceCapabilities(capabilities);\n\n      // Lock orientation on mobile\n      if (capabilities.touchSupport) {\n        MobileUtils.lockOrientation('portrait-primary');\n      }\n\n      // Request wake lock to keep screen on during inspection\n      const wakeLockInstance = await MobileUtils.requestWakeLock();\n      setWakeLock(wakeLockInstance);\n\n      // Load offline inspections\n      const storedInspections = await offlineStorage.getAllInspections();\n      setOfflineInspections(storedInspections);\n\n      // Request notification permission\n      await pwaManager.requestNotificationPermission();\n    };\n\n    initializePWA();\n\n    // PWA event listeners\n    pwaManager.on('beforeInstallPrompt', () => {\n      setShowInstallPrompt(true);\n    });\n\n    pwaManager.on('appInstalled', () => {\n      setShowInstallPrompt(false);\n      pwaManager.showNotification('App install√©e!', {\n        body: "Assistant d'Inspection est maintenant install√© sur votre appareil."\n      });\n    });\n\n    pwaManager.on('onlineStatus', ({ online }) => {\n      setIsOnline(online);\n      if (online) {\n        syncOfflineData();\n      }\n    });\n\n    pwaManager.on('syncComplete', ({ syncedCount }) => {\n      setSyncStatus(`${syncedCount} inspections synchronis√©es`);\n      setTimeout(() => setSyncStatus(''), 3000);\n    });\n\n    // Cleanup on unmount\n    return () => {\n      if (wakeLock) {\n        wakeLock.release();\n      }\n      MobileUtils.unlockOrientation();\n    };\n  }, []);\n\n  // Sync offline data when online\n  const syncOfflineData = useCallback(async () => {\n    if (!isOnline) return;\n    \n    try {\n      const unsyncedInspections = await offlineStorage.getUnsyncedInspections();\n      if (unsyncedInspections.length > 0) {\n        setSyncStatus('Synchronisation en cours...');\n        \n        // Register background sync\n        await pwaManager.registerBackgroundSync();\n        \n        // In a real app, you would send data to your server here\n        // For now, we'll just mark them as synced after a delay\n        setTimeout(async () => {\n          for (const inspection of unsyncedInspections) {\n            await offlineStorage.markInspectionSynced(inspection.id);\n          }\n          setSyncStatus(`${unsyncedInspections.length} inspections synchronis√©es`);\n          setTimeout(() => setSyncStatus(''), 3000);\n        }, 2000);\n      }\n    } catch (error) {\n      console.error('Sync failed:', error);\n      setSyncStatus('Erreur de synchronisation');\n      setTimeout(() => setSyncStatus(''), 3000);\n    }\n  }, [isOnline]);\n\n  const validateResponse = (response, question) => {\n    const lowerResponse = response.toLowerCase();\n    let errors = [];\n    \n    switch (question.type) {\n      case 'numeric':\n        const numberMatch = response.match(/(\\d+\\.?\\d*)/);\n        if (!numberMatch) {\n          errors.push('Aucun nombre d√©tect√© dans la r√©ponse');\n        } else {\n          const value = parseFloat(numberMatch[1]);\n          if (question.tolerance.includes('>=')) {\n            const minValue = parseFloat(question.tolerance.replace('>= ', ''));\n            if (value < minValue) {\n              errors.push(`Valeur trop faible (minimum: ${minValue}${question.unit || ''})`);\n            }\n          } else if (question.tolerance.includes('-')) {\n            const [min, max] = question.tolerance.split('-').map(v => parseFloat(v));\n            if (value < min || value > max) {\n              errors.push(`Valeur hors plage (attendu: ${min}-${max}${question.unit || ''})`);\n            }\n          }\n        }\n        break;\n        \n      case 'boolean':\n        if (!lowerResponse.includes('oui') && !lowerResponse.includes('non') && \n            !lowerResponse.includes('yes') && !lowerResponse.includes('no')) {\n          errors.push('R√©ponse non reconnue. Veuillez r√©pondre par \"oui\" ou \"non\"');\n        }\n        break;\n        \n      case 'descriptive':\n        if (response.trim().length < 3) {\n          errors.push('R√©ponse trop courte. Veuillez donner plus de d√©tails');\n        }\n        break;\n    }\n    \n    return errors;\n  };\n\n  const startListening = () => {\n    if (!('webkitSpeechRecognition' in window)) {\n      alert("La reconnaissance vocale n'est pas support√©e par votre navigateur.");\n      return;\n    }\n\n    // Vibrate on start (mobile feedback)\n    MobileUtils.vibrate([50]);\n\n    const recognition = new window.webkitSpeechRecognition();\n    recognition.lang = 'fr-FR';\n    recognition.continuous = false;\n    recognition.interimResults = false;\n    \n    recognition.onstart = () => {\n      setIsListening(true);\n      setTranscription('');\n      setValidationMessage('');\n    };\n    \n    recognition.onresult = (event) => {\n      const transcript = event.results[0][0].transcript;\n      setTranscription(transcript);\n      processResponse(transcript);\n      \n      // Success vibration\n      MobileUtils.vibrate([100, 50, 100]);\n    };\n    \n    recognition.onerror = (event) => {\n      console.error('Erreur de reconnaissance vocale:', event.error);\n      setIsListening(false);\n      \n      // Error vibration\n      MobileUtils.vibrate([200, 100, 200]);\n      \n      let errorMessage = 'Erreur de reconnaissance vocale.';\n      if (event.error === 'no-speech') {\n        errorMessage = 'Aucune parole d√©tect√©e. Veuillez r√©essayer.';\n      } else if (event.error === 'network') {\n        errorMessage = 'Erreur r√©seau. V√©rifiez votre connexion.';\n      }\n      \n      setValidationMessage(errorMessage);\n      setTimeout(() => setValidationMessage(''), 3000);\n    };\n    \n    recognition.onend = () => {\n      setIsListening(false);\n    };\n    \n    recognition.start();\n  };\n\n  const processResponse = (response) => {\n    const question = questions[currentQuestion];\n    const validationErrors = validateResponse(response, question);\n    \n    if (validationErrors.length > 0) {\n      setValidationMessage(validationErrors.join('. '));\n      MobileUtils.vibrate([300]); // Error vibration\n      setTimeout(() => setValidationMessage(''), 5000);\n      return;\n    }\n    \n    let processedValue = response.toLowerCase();\n    let status = 'unknown';\n    let displayValue = response;\n\n    switch (question.type) {\n      case 'numeric':\n        const numberMatch = response.match(/(\\d+\\.?\\d*)/);\n        if (numberMatch) {\n          processedValue = parseFloat(numberMatch[1]);\n          displayValue = `${processedValue} ${question.unit || ''}`;\n          \n          if (question.tolerance.includes('>=')) {\n            const minValue = parseFloat(question.tolerance.replace('>= ', ''));\n            status = processedValue >= minValue ? 'pass' : 'fail';\n          } else if (question.tolerance.includes('-')) {\n            const [min, max] = question.tolerance.split('-').map(v => parseFloat(v));\n            status = (processedValue >= min && processedValue <= max) ? 'pass' : 'fail';\n          }\n        }\n        break;\n        \n      case 'boolean':\n        if (processedValue.includes('oui') || processedValue.includes('yes')) {\n          status = 'pass';\n          displayValue = 'Oui';\n        } else if (processedValue.includes('non') || processedValue.includes('no')) {\n          status = 'fail';\n          displayValue = 'Non';\n        }\n        break;\n        \n      case 'descriptive':\n        displayValue = response;\n        if (processedValue.includes('bon') || processedValue.includes('bonne')) {\n          status = 'pass';\n        } else if (processedValue.includes('mauvais') || processedValue.includes('mauvaise') || processedValue.includes('remplacer')) {\n          status = 'fail';\n        } else {\n          status = 'warning';\n        }\n        break;\n        \n      default:\n        displayValue = response;\n    }\n\n    setPendingResponse({\n      question: question.question, \n      response: displayValue, \n      status,\n      category: getCategoryFromKey(question.key)\n    });\n    setShowConfirmation(true);\n  };\n\n  const confirmResponse = async () => {\n    const newResponses = [...responses, pendingResponse];\n    setResponses(newResponses);\n    \n    // Save to offline storage\n    if (currentQuestion === questions.length - 1) {\n      // Complete inspection\n      const inspectionData = {\n        responses: newResponses,\n        completedAt: new Date().toISOString(),\n        deviceInfo: pwaManager.getDeviceInfo(),\n        batteryInfo: deviceCapabilities.batteryInfo\n      };\n      \n      try {\n        await offlineStorage.saveInspection(inspectionData);\n        \n        // Show completion notification\n        pwaManager.showNotification('Inspection termin√©e!', {\n          body: 'Les donn√©es ont √©t√© sauvegard√©es localement.',\n          vibrate: [100, 50, 100, 50, 100]\n        });\n        \n        // Success vibration pattern\n        MobileUtils.vibrate([100, 50, 100, 50, 100]);\n        \n        // Sync if online\n        if (isOnline) {\n          syncOfflineData();\n        }\n      } catch (error) {\n        console.error('Failed to save inspection:', error);\n        setValidationMessage('Erreur lors de la sauvegarde. Veuillez r√©essayer.');\n      }\n    }\n    \n    setCurrentQuestion(currentQuestion + 1);\n    setShowConfirmation(false);\n    setPendingResponse(null);\n    setTranscription('');\n  };\n\n  const rejectResponse = () => {\n    setShowConfirmation(false);\n    setPendingResponse(null);\n    setTranscription('');\n    MobileUtils.vibrate([50]); // Gentle feedback\n  };\n\n  const getCategoryFromKey = (key) => {\n    if (key.includes('brake')) return 'Freinage';\n    if (key.includes('tire')) return 'Pneumatiques';\n    if (key.includes('light') || key.includes('indicator')) return '√âclairage';\n    if (key.includes('oil') || key.includes('coolant') || key.includes('fluid')) return 'Fluides';\n    if (key.includes('belt') || key.includes('battery')) return 'M√©canique';\n    if (key.includes('windshield') || key.includes('horn') || key.includes('mirror')) return 'S√©curit√©';\n    if (key.includes('suspension') || key.includes('steering')) return 'Suspension/Direction';\n    return 'G√©n√©ral';\n  };\n\n  const skipQuestion = () => {\n    setResponses([...responses, { \n      question: questions[currentQuestion].question, \n      response: 'Question ignor√©e', \n      status: 'unknown',\n      category: getCategoryFromKey(questions[currentQuestion].key)\n    }]);\n    setCurrentQuestion(currentQuestion + 1);\n    MobileUtils.vibrate([50]); // Gentle feedback\n  };\n\n  const restartInspection = () => {\n    setCurrentQuestion(0);\n    setResponses([]);\n    setTranscription('');\n    setPendingResponse(null);\n    setShowConfirmation(false);\n    MobileUtils.vibrate([100]); // Restart feedback\n  };\n\n  const exportReport = async () => {\n    const reportData = {\n      date: new Date().toLocaleString('fr-FR'),\n      questions: questions.length,\n      responses: responses,\n      summary: {\n        pass: responses.filter(r => r.status === 'pass').length,\n        fail: responses.filter(r => r.status === 'fail').length,\n        warning: responses.filter(r => r.status === 'warning').length,\n        unknown: responses.filter(r => r.status === 'unknown').length\n      },\n      deviceInfo: pwaManager.getDeviceInfo(),\n      offlineMode: !isOnline\n    };\n    \n    // Try to share using Web Share API first\n    const shareData = {\n      title: `Rapport d'Inspection M√©canique`,\n      text: `Inspection termin√©e: ${reportData.summary.pass} conformes, ${reportData.summary.fail} non conformes`,\n      url: window.location.href\n    };\n    \n    const shared = await pwaManager.share(shareData);\n    \n    if (!shared) {\n      // Fallback to file download\n      const blob = new Blob([JSON.stringify(reportData, null, 2)], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `inspection-report-${new Date().toISOString().split('T')[0]}.json`;\n      a.click();\n      URL.revokeObjectURL(url);\n    }\n    \n    MobileUtils.vibrate([100]); // Export feedback\n  };\n\n  const installApp = async () => {\n    const installed = await pwaManager.showInstallPrompt();\n    if (installed) {\n      setShowInstallPrompt(false);\n    }\n  };\n\n  return (\n    <div className=\"inspection-assistant\">\n      {/* PWA Status Bar */}\n      <div className=\"pwa-status-bar\">\n        <div className=\"connection-status\">\n          <span className={`status-indicator ${isOnline ? 'online' : 'offline'}`}>\n            {isOnline ? 'üü¢ En ligne' : 'üî¥ Hors ligne'}\n          </span>\n          {syncStatus && (\n            <span className=\"sync-status\">üì§ {syncStatus}</span>\n          )}\n        </div>\n        \n        {showInstallPrompt && (\n          <button className=\"install-button\" onClick={installApp}>\n            üì± Installer l'app\n          </button>\n        )}\n      </div>\n\n      <header className=\"app-header\">\n        <h1>üîß Assistant d'Inspection M√©canique</h1>\n        <p>\n          Inspection vocale automatis√©e pour v√©hicules\n          {!isOnline && <span className=\"offline-badge\"> ‚Ä¢ Mode hors ligne</span>}\n        </p>\n      </header>\n\n      <div className=\"current-question\">\n        <div className=\"question-header\">\n          <span className=\"question-counter\">\n            Question {currentQuestion + 1} sur {questions.length}\n          </span>\n          {currentQuestion < questions.length && (\n            <span className=\"category-badge\">\n              {getCategoryFromKey(questions[currentQuestion].key)}\n            </span>\n          )}\n        </div>\n        \n        <div className=\"question-text\">\n          {questions[currentQuestion]?.question || 'Inspection termin√©e !'}\n        </div>\n        \n        <div className=\"progress-bar\">\n          <div \n            className=\"progress-fill\" \n            style={{ width: `${(currentQuestion / questions.length) * 100}%` }}\n          ></div>\n        </div>\n      </div>\n\n      {validationMessage && (\n        <div className=\"validation-error\">\n          <span className=\"error-icon\">‚ö†Ô∏è</span>\n          {validationMessage}\n        </div>\n      )}\n\n      {showConfirmation && pendingResponse && (\n        <div className=\"confirmation-dialog\">\n          <div className=\"confirmation-content\">\n            <h3>Confirmer la r√©ponse</h3>\n            <div className=\"confirmation-details\">\n              <p><strong>Question :</strong> {pendingResponse.question}</p>\n              <p><strong>Votre r√©ponse :</strong> {pendingResponse.response}</p>\n              <div className={`status-preview ${pendingResponse.status}`}>\n                <span className=\"status-icon\">\n                  {pendingResponse.status === 'pass' ? '‚úì' : \n                   pendingResponse.status === 'fail' ? '‚úó' : \n                   pendingResponse.status === 'warning' ? '‚ö†' : '?'}\n                </span>\n                <span className=\"status-text\">\n                  {pendingResponse.status === 'pass' ? 'Conforme' : \n                   pendingResponse.status === 'fail' ? 'Non conforme' : \n                   pendingResponse.status === 'warning' ? '√Ä surveiller' : 'Ind√©termin√©'}\n                </span>\n              </div>\n            </div>\n            <div className=\"confirmation-buttons\">\n              <button className=\"confirm-btn\" onClick={confirmResponse}>\n                ‚úì Confirmer\n              </button>\n              <button className=\"reject-btn\" onClick={rejectResponse}>\n                üé§ R√©enregistrer\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n\n      <div className=\"controls\">\n        <button \n          className={`voice-button ${isListening ? 'listening' : ''}`}\n          onClick={startListening} \n          disabled={isListening || currentQuestion >= questions.length || showConfirmation}\n        >\n          {isListening ? 'üé§ √âcoute en cours...' : \n           currentQuestion >= questions.length ? '‚úÖ Inspection termin√©e' : 'üé§ R√©pondre'}\n        </button>\n        \n        {currentQuestion > 0 && currentQuestion < questions.length && !showConfirmation && (\n          <button className=\"skip-button\" onClick={skipQuestion}>\n            ‚è≠Ô∏è Ignorer cette question\n          </button>\n        )}\n\n        {currentQuestion >= questions.length && responses.length > 0 && (\n          <div className=\"final-actions\">\n            <button className=\"restart-button\" onClick={restartInspection}>\n              üîÑ Nouvelle inspection\n            </button>\n            <button className=\"export-button\" onClick={exportReport}>\n              üìÑ Partager le rapport\n            </button>\n          </div>\n        )}\n      </div>\n\n      {transcription && !showConfirmation && (\n        <div className=\"last-transcription\">\n          <strong>Derni√®re r√©ponse :</strong> {transcription}\n        </div>\n      )}\n\n      <div className=\"inspection-log\">\n        <h2>Journal d'inspection</h2>\n        {responses.length === 0 ? (\n          <p className=\"no-responses\">Aucune r√©ponse enregistr√©e</p>\n        ) : (\n          <div className=\"responses-grid\">\n            {responses.map((response, index) => (\n              <div key={index} className={`response-card ${response.status}`}>\n                <div className=\"response-header\">\n                  <span className=\"category\">{response.category}</span>\n                  <span className={`status-badge ${response.status}`}>\n                    {response.status === 'pass' ? '‚úì' : \n                     response.status === 'fail' ? '‚úó' : \n                     response.status === 'warning' ? '‚ö†' : '?'}\n                  </span>\n                </div>\n                <p className=\"question\">{response.question}</p>\n                <p className=\"response-value\">{response.response}</p>\n              </div>\n            ))}\n          </div>\n        )}\n        \n        {currentQuestion >= questions.length && responses.length > 0 && (\n          <div className=\"inspection-summary\">\n            <h3>R√©sum√© de l'inspection</h3>\n            <div className=\"summary-stats\">\n              <span className=\"stat pass\">\n                ‚úì {responses.filter(r => r.status === 'pass').length} Conformes\n              </span>\n              <span className=\"stat fail\">\n                ‚úó {responses.filter(r => r.status === 'fail').length} Non conformes\n              </span>\n              <span className=\"stat warning\">\n                ‚ö† {responses.filter(r => r.status === 'warning').length} √Ä surveiller\n              </span>\n              <span className=\"stat unknown\">\n                ? {responses.filter(r => r.status === 'unknown').length} Ind√©termin√©s\n              </span>\n            </div>\n            \n            {!isOnline && (\n              <div className=\"offline-notice\">\n                üì± Inspection sauvegard√©e localement. Sera synchronis√©e une fois en ligne.\n              </div>\n            )}\n          </div>\n        )}\n        \n        {offlineInspections.length > 0 && (\n          <div className=\"offline-inspections\">\n            <h4>Inspections hors ligne ({offlineInspections.length})</h4>\n            <p>Ces inspections seront synchronis√©es automatiquement.</p>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default VoiceInspectionAssistant;